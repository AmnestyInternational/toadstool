#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "thor"
require "thor/group"
require 'pathname'

APP_PATH = File.expand_path(File.join(__FILE__, '../../templates'))

module Toadstool
  class Install < Thor::Group
    include Thor::Actions

    # Define arguments and options
    argument :name, {:default => './'}
    class_option :styleguide_directory, :type => :string, :default => "./styleguide/", :desc => 'The directory for the Toadstool app.'

    def self.source_root
      APP_PATH
    end

    def install_app
      directory "project/doc-src", "#{install_directory}/doc-src"
      directory "project/public", "#{install_directory}/public"
      directory "project/sass", "#{install_directory}/sass"
      directory "project/views", "#{install_directory}/views"

      copy_file "project/config.rb", "#{install_directory}/config.rb"
      copy_file "project/config.ru", "#{install_directory}/config.ru"
      copy_file "project/Gemfile", "#{install_directory}/Gemfile"
      copy_file "project/Rakefile", "#{install_directory}/Rakefile"
      copy_file "project/readme.md", "#{install_directory}/readme.md"
      copy_file "project/toadstool.rb", "#{install_directory}/toadstool.rb"
    end

    def install_directory
      File.join('./', name, options[:styleguide_directory])
    end
  end

  class Server < Thor::Group
    def start # no desc
      
      cwd = Dir.pwd
      return unless in_toadstool_app? || in_app_subdirectory?
      exec 'rackup', *ARGV if in_toadstool_app?
      Dir.chdir("..") do
        # Recurse in a chdir block: if the search fails we want to be sure
        # the application is generated in the original working directory.
        start! unless cwd == Dir.pwd
      end
      rescue SystemCallError
        # could not chdir, no problem just return
    end

    no_tasks do
      def in_toadstool_app?
        File.exists?('toadstool.rb') && File.exists?('config.ru')
      end

      def in_app_subdirectory?(path = Pathname.new(Dir.pwd))
        File.exists?(File.join(path, 'config.ru')) || !path.root? && in_app_subdirectory?(path.parent)
      end
    end
  end

  class Generator < Thor
    def self.source_root
      APP_PATH
    end

    include Thor::Actions
    argument :category
    argument :name

    desc 'ts_module', "Generate a module"
    def ts_module
      directory "module/views", "views/modules/#{category}"
      directory "module/sass", "sass/modules/#{category}"

      append_file 'sass/_modules.scss', "@import 'modules/#{category}/#{name}/#{name}'"
    end

    desc 'pattern', "Generate a module"
    def pattern
      directory "pattern/views", "views/ui_patterns/#{category}"
      directory "pattern/sass", "sass/ui_patterns/#{category}"

      append_file 'sass/_ui_patterns.scss', "@import 'ui_patterns/#{category}/#{name}/#{name}'"
    end

    no_tasks do
      def module_name
        "#{name}"
      end

      def pattern_name
        "#{name}"
      end
    end

    map 'module' => 'ts_module'
  end
end




ARGV << '--help' if ARGV.empty?

aliases = {
  "i"  => "install",
  "new"  => "install",
  "s"  => "server",
  "g"  => "generate"
}


help_message = <<-EOT
Usage: toadstool COMMAND [ARGS]

The most common rails commands are:
 server      Start the Toadstool server (short-cut alias: "s")
 new         Create a new Toadstool application. "toadstool new my_styleguide" creates a
             new application in "./my_styleguide"

All commands can be run with -h (or --help) for more information.
EOT

command = ARGV.shift
command = aliases[command] || command

case command
when 'install'
  Toadstool::Install.start
when 'server'
  Toadstool::Server.start
when 'generate'
  Toadstool::Generator.start
else
  puts "Error: Command '#{command}' not recognized"
  if %x{rake #{command} --dry-run 2>&1 } && $?.success?
    puts "Did you mean: `$ rake #{command}` ?\n\n"
  end
  puts help_message
  exit(1)
end