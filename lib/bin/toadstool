#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "thor"
require "thor/group"
require 'pathname'

APP_PATH = File.expand_path(File.join(__FILE__, '../../templates'))

module Toadstool
  class Install < Thor::Group
    include Thor::Actions

    # Define arguments and options
    argument :name, {:default => './'}
    class_option :styleguide_directory, :type => :string, :default => "./styleguide/", :desc => 'The directory for the Toadstool app.'

    def self.source_root
      APP_PATH
    end

    def install_app
      directory "project/doc-src", "#{install_directory}/doc-src"
      directory "project/public", "#{install_directory}/public"
      directory "project/sass", "#{install_directory}/sass"
      directory "project/views", "#{install_directory}/views"

      copy_file "project/config.rb", "#{install_directory}/config.rb"
      copy_file "project/config.ru", "#{install_directory}/config.ru"
      copy_file "project/Gemfile", "#{install_directory}/Gemfile"
      copy_file "project/Rakefile", "#{install_directory}/Rakefile"
      copy_file "project/readme.md", "#{install_directory}/readme.md"
      copy_file "project/toadstool.rb", "#{install_directory}/toadstool.rb"
    end
    
    def install_directory
      File.join('./', name, options[:styleguide_directory])
    end
  end

  class Server < Thor::Group
    def exec_script_rails!
      cwd = Dir.pwd
      return unless in_rails_application? || in_rails_application_subdirectory?
      exec 'rackup', *ARGV if in_rails_application?
      Dir.chdir("..") do
        # Recurse in a chdir block: if the search fails we want to be sure
        # the application is generated in the original working directory.
        exec_script_rails! unless cwd == Dir.pwd
      end
      rescue SystemCallError
        # could not chdir, no problem just return
    end
  end

   # no_tasks do
     def in_rails_application?
       File.exists?('config.ru')
     end


     def in_rails_application_subdirectory?(path = Pathname.new(Dir.pwd))
       File.exists?(File.join(path, 'config.ru')) || !path.root? && in_rails_application_subdirectory?(path.parent)
     end
   # end

# end
#
#
# module Toadstool
  class Generator < Thor
    def self.source_root
      APP_PATH
    end

    include Thor::Actions
      argument :truffle
      argument :oil

      desc 'ts_module', "Generate a module"
      def ts_module
        directory "module/views", "views/modules/#{truffle}"
        directory "module/sass", "sass/modules/#{truffle}"

        create_file 'sass/_modules.sass' if !File.exist?('sass/_modules.sass')

        append_file 'sass/_modules.sass', "@import 'modules/#{truffle}/#{oil}/#{oil}'"
      end

      desc 'pattern', "Generate a module"
      def pattern
        directory "pattern/views", "views/ui_patterns/#{truffle}"
        directory "pattern/sass", "sass/ui_patterns/#{truffle}"

        create_file 'sass/_ui_patterns.sass' if !File.exist?('sass/_ui_patterns.sass')

        append_file 'sass/_ui_patterns.sass', "@import 'ui_patterns/#{truffle}/#{oil}/#{oil}'"
      end

      no_tasks do
        def shiitake
          "#{oil}"
        end
      end

      map 'module' => 'ts_module'
    end
end




ARGV << '--help' if ARGV.empty?

aliases = {
  "i"  => "install",
  "new"  => "install",
  "s"  => "server",
  "g"  => "generate"
}


help_message = <<-EOT
Usage: toadstool COMMAND [ARGS]

The most common rails commands are:
 server      Start the Toadstool server (short-cut alias: "s")
 new         Create a new Toadstool application. "toadstool new my_styleguide" creates a
             new application in "./my_styleguide"

All commands can be run with -h (or --help) for more information.
EOT

command = ARGV.shift
command = aliases[command] || command

case command
when 'install'
  Toadstool::Install.start
when 'server'
  Toadstool::Server.start
when 'generate'
  Toadstool::Generator.start
else
  puts "Error: Command '#{command}' not recognized"
  if %x{rake #{command} --dry-run 2>&1 } && $?.success?
    puts "Did you mean: `$ rake #{command}` ?\n\n"
  end
  puts help_message
  exit(1)
end